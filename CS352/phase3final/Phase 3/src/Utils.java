/**
 * 
 * @author Omar Khalil ok77
 * 
 */

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Arrays;

import givenTools.TorrentInfo;

public class Utils {
	
	private static Tracker tracker = RUBTClient.tracker;
	private static TorrentInfo torrent_info = tracker.torrent_info;
	private static byte[] bit_protocol = new byte[] {'B','i','t','T','o','r','r','e','n','t',' ','p','r','o','t','o','c','o','l'};
	
	public static int index;
	
	/**
	 * Checks if the file to be saved has been started already. If so, reads all pieces from the save file to
	 * the downloaded file array by verifying its SHA-1 hash. Returns the index of the piece to resume download
	 * 
	 */
	public static void checkFileAndGetIndex() {
		File file = new File(RUBTClient.save_file);
		FileInputStream fis;
		
		if (file.exists()) {
			try {
				fis = new FileInputStream(file);
				int count = 0; 	
				int pieces = torrent_info.piece_hashes.length;
				
				while (count != pieces) {
					byte[] piece;
					if (count == pieces - 1) {
						if (torrent_info.file_length % torrent_info.piece_length == 0) {
							piece = new byte[torrent_info.piece_length];
						} else {
							piece = new byte[torrent_info.file_length % torrent_info.piece_length];
						}
					} else {
						piece = new byte[torrent_info.piece_length];
					}
					
					fis.read(piece);
					if (verifySHA1(piece, count)) {
						Tracker.updateFile(piece, count * torrent_info.piece_length, piece.length);
						tracker.downloaded += piece.length;
						tracker.left -= piece.length;
						tracker.downloaded_pieces[count] = true;
					} else {
						fis.close();
						index = count;
						return;
					}
					
					count++;
				}
				
				if (count == pieces) {
					fis.close();
					index = count;
					return;
				}
				
				fis.close();
			} catch (IOException e) {
				System.err.println("File input stream error");
				e.printStackTrace();
			}
		}
	
		index = 0;
	}
	
	/**
	 * Obtains a specific piece and verifies its SHA-1 hash value.
	 * 
	 * @param piece
	 * @param count
	 * @return True if SHA-1 is verified. False otherwise.
	 */
	public static boolean verifySHA1(byte[] piece, int count) {
		MessageDigest md = null;
		byte[] b = null;
		try {
			md = MessageDigest.getInstance("SHA-1");
			b = md.digest(piece);
		} catch (NoSuchAlgorithmException e) {
			System.err.println("Verifying SHA-1 error");
		}

		byte[] check = torrent_info.piece_hashes[count].array();
		if (Arrays.equals(b, check)) {
			return true;
		}

		return false;
		
	}
	
	/**
	 * Creates a handshake to send to the peer
	 * 
	 * @return byte[] of handshake message
	 */
	public static byte[] createHandshake() {
		byte[] info_hash = tracker.info_hash;
		
		// begins with byte 19
		byte[] handshake_message = new byte[68];
		handshake_message[0] = (byte) 19;

		// "BitTorrent protocol" 
		System.arraycopy(bit_protocol, 0, handshake_message, 1, bit_protocol.length);
		int index = 1 + bit_protocol.length;

		// 8 reserved bytes that are set to 0
		byte[] reserved_bytes = new byte[8];
		System.arraycopy(reserved_bytes, 0, handshake_message, index, reserved_bytes.length);

		// 20-byte SHA-1 hash of the bencoded form of the torrent info value
		index += reserved_bytes.length;
		System.arraycopy(info_hash, 0, handshake_message, index, info_hash.length);

		// peed id generated by the client
		byte[] generated_ID = tracker.peer_id.getBytes();
		index += info_hash.length;
		System.arraycopy(generated_ID, 0, handshake_message, index, generated_ID.length);
		
		return handshake_message;
	}
	
}
